// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ IMPORTS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CODE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

parser code {:

	Logger log = Logger.getLogger(getClass());
	boolean errorDetected;
   
    // Redefined error handling methods
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
      errorDetected = true;
    }
  
    public void syntax_error(String message, Symbol cur_token) {
        report_error("\nSyntax error: " + message, cur_token);
        errorDetected = true;
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
        errorDetected = true;
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
        errorDetected = true;
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

init with {:
	errorDetected = false;
:}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GRAMMAR ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~




// ~~~~~~~~~~~~~~~~NONTERMINALS~~~~~~~~~~~~~~~~

nonterminal ProgramDeclListE ProgramDeclListE;
nonterminal MethodDeclListE MethodDeclListE;
nonterminal ConstDecl ConstDecl;
nonterminal VarDecl VarDecl;
nonterminal ClassDecl ClassDecl;
nonterminal ConstDeclInnerList ConstDeclInnerList;
nonterminal VarDeclInnerList VarDeclInnerList;
nonterminal SquareBracketsOptional SquareBracketsOptional;
nonterminal ExtendsTypeOptional ExtendsTypeOptional;
nonterminal ClassBody ClassBody;
nonterminal VarDeclListE VarDeclListE;
nonterminal ClassConstructorsAndMethodsDeclOptional ClassConstructorsAndMethodsDeclOptional;
nonterminal ConstructorDeclListE ConstructorDeclListE;
nonterminal ConstructorDecl ConstructorDecl;
nonterminal MethodDecl MethodDecl;
nonterminal MethodReturnType MethodReturnType;
nonterminal FormParsOptional FormParsOptional;
nonterminal StatementListE StatementListE;
nonterminal FormPars FormPars;
nonterminal Statement Statement;
nonterminal MatchedStatement MatchedStatement;
nonterminal UnmatchedStatement UnmatchedStatement;
nonterminal Condition Condition;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal ExprOptional ExprOptional;
nonterminal PrintNumConstOptional PrintNumConstOptional;
nonterminal DesignatorAction DesignatorAction;
nonterminal DesignatorListOptionalES DesignatorListOptionalES;
nonterminal ActParsOptional ActParsOptional;
nonterminal Assignop Assignop;
nonterminal DesignatorList DesignatorList;
nonterminal ActPars ActPars;
nonterminal CondTerm CondTerm;
nonterminal CondFact CondFact;
nonterminal RelopExprOptional RelopExprOptional;
nonterminal Relop Relop;
nonterminal TermAddopList TermAddopList;
nonterminal Addop Addop;
nonterminal Mulop Mulop;
nonterminal ParenActParsOptional ParenActParsOptional;
nonterminal NewTypeSuffix NewTypeSuffix;
nonterminal Label Label;
nonterminal VarDeclGlobal VarDeclGlobal;
nonterminal VarDeclInnerListGlobal VarDeclInnerListGlobal;
nonterminal DesignatorAssignopExpr DesignatorAssignopExpr;
nonterminal StatementWhileStart StatementWhileStart;

nonterminal IfStatement IfStatement;
nonterminal ElseStatement ElseStatement;

// Everything that needs to go inside Tab
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgramName, Program, Const, ClassName, MethodName, Designator;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Factor, Term, Expr;

nonterminal ConstDeclInnerListElement ConstDeclInnerListElement;
nonterminal VarDeclInnerListElement VarDeclInnerListElement;
nonterminal FormParam FormParam;
nonterminal DesignatorOptional DesignatorOptional;
nonterminal ForeachStatement ForeachStatement;
nonterminal ConditionInIf ConditionInIf;




// ~~~~~~~~~~~~~~~~TERMINALS~~~~~~~~~~~~~~~~

// Keywords
terminal PROGRAM, BREAK, CLASS, ELSE, CONST, IF, WHILE, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE, FOREACH;

// Operators
terminal PLUS, MINUS, MUL, DIV, MOD, EQUALS, NOT_EQUALS, GREATER, GREATER_EQUALS, LESS, LESS_EQUALS, AND, OR, ASSIGN;
terminal INC, DEC, SEMI_COLON, COLON, COMMA, DOT, L_PAREN, R_PAREN, L_SQUARE_BRACKET, R_SQUARE_BRACKET, L_BRACE, R_BRACE, ARROW;

// Token types
terminal String IDENT;
terminal Integer NUM_CONST;
terminal Boolean BOOL_CONST;
terminal Character CHAR_CONST;



// ~~~~~~~~~~~~~~~~PRECEDENCE~~~~~~~~~~~~~~~~

precedence left ELSE;




// ~~~~~~~~~~~~~~~~RULES~~~~~~~~~~~~~~~~

Program ::= (Program) PROGRAM ProgramName:programName ProgramDeclListE:P1 L_BRACE MethodDeclListE:M2 R_BRACE {: RESULT=new Program(programName, P1, M2); RESULT.setLine(programNameleft); :};

ProgramName ::= (ProgramName) IDENT:programName {: RESULT=new ProgramName(programName); RESULT.setLine(programNameleft); :};

ProgramDeclListE ::= (ProgramDeclListEConst) ProgramDeclListE:P1 ConstDecl:C2 {: RESULT=new ProgramDeclListEConst(P1, C2); RESULT.setLine(P1left); :}
				|
				(ProgramDeclListEVar) ProgramDeclListE:P1 VarDeclGlobal:V2 {: RESULT=new ProgramDeclListEVar(P1, V2); RESULT.setLine(P1left); :}
				|
				(ProgramDeclListEClass) ProgramDeclListE:P1 ClassDecl:C2 {: RESULT=new ProgramDeclListEClass(P1, C2); RESULT.setLine(P1left); :}
				|
				(ProgramDeclListEEmpty) {: RESULT=new ProgramDeclListEEmpty(); :} /* e */
				;
				
ConstDecl ::= (ConstDecl) CONST Type:T1 ConstDeclInnerList:C2 SEMI_COLON {: RESULT=new ConstDecl(T1, C2); RESULT.setLine(T1left); :};

ConstDeclInnerList ::= (ConstDeclInnerListSingle) ConstDeclInnerListElement:C1 {: RESULT=new ConstDeclInnerListSingle(C1); RESULT.setLine(C1left); :}
			|
			(ConstDeclInnerListMultiple) ConstDeclInnerList:C1 COMMA ConstDeclInnerListElement:C2 {: RESULT=new ConstDeclInnerListMultiple(C1, C2); RESULT.setLine(C1left); :}
			;

ConstDeclInnerListElement ::= (ConstDeclInnerListElement) IDENT:constName ASSIGN Const:C1 {: RESULT=new ConstDeclInnerListElement(constName, C1); RESULT.setLine(constNameleft); :};

Const ::= (ConstNum) NUM_CONST:value {: RESULT=new ConstNum(value); RESULT.setLine(valueleft); :}
		|
		(ConstBool) BOOL_CONST:value {: RESULT=new ConstBool(value); RESULT.setLine(valueleft); :}
		|
		(ConstChar) CHAR_CONST:value {: RESULT=new ConstChar(value); RESULT.setLine(valueleft); :}
		;
		
VarDeclGlobal ::= (VarDeclGlobalExists) VarDecl:V1 {: RESULT=new VarDeclGlobalExists(V1); RESULT.setLine(V1left); :}
				|
				(VarDeclGlobalError) error:e 
					{: 
						parser.syntax_error("Globar var declaration error at line: " + eleft, null); 
						parser.log.info("Global var declaration error recovery successful."); 
					:} {: RESULT=new VarDeclGlobalError(); :}
				;

VarDecl ::= (VarDecl) Type:T1 VarDeclInnerList:V2 SEMI_COLON {: RESULT=new VarDecl(T1, V2); RESULT.setLine(T1left); :};

//VarDeclInnerListGlobal ::= (VarDeclInnerListGlobalSingle) IDENT SquareBracketsOptional
//				|
//				(VarDeclInnerListGlobalMultiple) VarDeclInnerListGlobal COMMA IDENT SquareBracketsOptional
//				|
//				(VarDeclInnerListGlobalError) error:e {: parser.report_error("Globar var declaration error at line: " + eleft, null); :}
//				;

VarDeclInnerList ::= (VarDeclInnerListSingle) VarDeclInnerListElement:V1 {: RESULT=new VarDeclInnerListSingle(V1); RESULT.setLine(V1left); :}
				|
				(VarDeclInnerListMultiple) VarDeclInnerList:V1 COMMA VarDeclInnerListElement:V2 {: RESULT=new VarDeclInnerListMultiple(V1, V2); RESULT.setLine(V1left); :}
				;
				
VarDeclInnerListElement ::= (VarDeclInnerListElementVar) IDENT:varName {: RESULT=new VarDeclInnerListElementVar(varName); RESULT.setLine(varNameleft); :}
						|
						(VarDeclInnerListElementArray) IDENT:varName L_SQUARE_BRACKET R_SQUARE_BRACKET {: RESULT=new VarDeclInnerListElementArray(varName); RESULT.setLine(varNameleft); :}
						;

SquareBracketsOptional ::= (SquareBracketsOptionalExists) L_SQUARE_BRACKET R_SQUARE_BRACKET {: RESULT=new SquareBracketsOptionalExists(); :}
						|
						(SquareBracketsOptionalEmpty) {: RESULT=new SquareBracketsOptionalEmpty(); :} /* e */ 
						;
						
			
						
ClassDecl ::= (ClassDecl) CLASS ClassName:className ExtendsTypeOptional:E1 L_BRACE ClassBody:C2 R_BRACE {: RESULT=new ClassDecl(className, E1, C2); RESULT.setLine(classNameleft); :};

ClassName ::= (ClassName) IDENT:className {: RESULT=new ClassName(className); RESULT.setLine(classNameleft); :};

ExtendsTypeOptional ::= (ExtendsTypeOptionalExists) EXTENDS Type:T1 {: RESULT=new ExtendsTypeOptionalExists(T1); RESULT.setLine(T1left); :}
					|
					(ExtendsTypeOptionalEmpty) {: RESULT=new ExtendsTypeOptionalEmpty(); :} /* e */
					|
					(ExtendsTypeOptionalError) error:e 
						{: 
							parser.syntax_error("Class extends type error at line: " + eleft, null); 
							parser.log.info("Class extends type error recovery successful."); 
						:} {: RESULT=new ExtendsTypeOptionalError(); :}
					;

ClassBody ::= (ClassBody) VarDeclListE:V1 ClassConstructorsAndMethodsDeclOptional:C2 {: RESULT=new ClassBody(V1, C2); RESULT.setLine(V1left); :};

VarDeclListE ::= (VarDeclListEExists) VarDeclListE:V1 VarDecl:V2 {: RESULT=new VarDeclListEExists(V1, V2); RESULT.setLine(V1left); :}
			|
			(VarDeclListEEmpty) {: RESULT=new VarDeclListEEmpty(); :} /* e */
			;

ClassConstructorsAndMethodsDeclOptional ::= (ClassConstructorsAndMethodsDeclOptionalExists) L_BRACE /* ConstructorDeclListE */ MethodDeclListE:M1 R_BRACE {: RESULT=new ClassConstructorsAndMethodsDeclOptionalExists(M1); RESULT.setLine(M1left); :}
										|
										(ClassConstructorsAndMethodsDeclOptionalEmpty) {: RESULT=new ClassConstructorsAndMethodsDeclOptionalEmpty(); :} /* e */
										;

// Level C
//ConstructorDeclListE ::= (ConstructorDeclListEExists) ConstructorDeclListE ConstructorDecl
//						|
//						(ConstructorDeclListEEmpty) /* e */
//						;
//
//ConstructorDecl ::= (ConstructorDeclEmpty) /* e */; // Level C


MethodDeclListE ::= (MethodDeclListEExists) MethodDeclListE:M1 MethodDecl:M2 {: RESULT=new MethodDeclListEExists(M1, M2); RESULT.setLine(M1left); :}
				|
				(MethodDeclListEEmpty) {: RESULT=new MethodDeclListEEmpty(); :} /* e */
				;

MethodDecl ::= (MethodDecl) MethodReturnType:M1 MethodName:methodName L_PAREN FormParsOptional:F2 R_PAREN VarDeclListE:V3 L_BRACE StatementListE:S4 R_BRACE {: RESULT=new MethodDecl(M1, methodName, F2, V3, S4); RESULT.setLine(M1left); :};

MethodName ::= (MethodName) IDENT:MethodName {: RESULT=new MethodName(MethodName); RESULT.setLine(MethodNameleft); :};

MethodReturnType ::= (MethodReturnTypeHasType) Type:returnType {: RESULT=new MethodReturnTypeHasType(returnType); RESULT.setLine(returnTypeleft); :}
					|
					(MethodReturnTypeIsVoid) VOID {: RESULT=new MethodReturnTypeIsVoid(); :}
					;
					
FormParsOptional ::= (FormParsOptionalExists) FormPars:F1 {: RESULT=new FormParsOptionalExists(F1); RESULT.setLine(F1left); :}
					|
					(FormParsOptionalEmpty) {: RESULT=new FormParsOptionalEmpty(); :} /* e */
					;
					
FormPars ::= (FormParsSingle) FormParam:F1 {: RESULT=new FormParsSingle(F1); RESULT.setLine(F1left); :}
			|
			(FormParsMultiple) FormPars:F1 COMMA FormParam:F2 {: RESULT=new FormParsMultiple(F1, F2); RESULT.setLine(F1left); :}
			|	
			(FormParsError) error:e 
				{: 
					parser.syntax_error("Formal parameter declaration error at line: " + eleft, null); 
					parser.log.info("Formal parameter declaration error recovery successful."); 
				:} {: RESULT=new FormParsError(); :}
			;
			
FormParam ::= (FormParamVar) Type:type IDENT:paramName {: RESULT=new FormParamVar(type, paramName); RESULT.setLine(typeleft); :}
			|
			(FormParamArray) Type:type IDENT:paramName L_SQUARE_BRACKET R_SQUARE_BRACKET {: RESULT=new FormParamArray(type, paramName); RESULT.setLine(typeleft); :}
			;

Type ::= (Type) IDENT:typeName {: RESULT=new Type(typeName); RESULT.setLine(typeNameleft); :};

StatementListE ::= (StatementListEExists) StatementListE:S1 Statement:S2 {: RESULT=new StatementListEExists(S1, S2); RESULT.setLine(S1left); :}
				|
				(StatementListEEmpty) {: RESULT=new StatementListEEmpty(); :} /* e */
				;
				
Statement ::= (StatementDesignator) DesignatorStatement:D1 SEMI_COLON {: RESULT=new StatementDesignator(D1); RESULT.setLine(D1left); :}
			|
			(StatementIfElse) IfStatement:I1 ElseStatement:E2 {: RESULT=new StatementIfElse(I1, E2); RESULT.setLine(I1left); :}	// TODO
			|
			(StatementIf) IfStatement:I1 {: RESULT=new StatementIf(I1); RESULT.setLine(I1left); :}	// TODO
			|
			(StatementWhile) StatementWhileStart:S1 L_PAREN Condition:C2 R_PAREN Statement:S3 {: RESULT=new StatementWhile(S1, C2, S3); RESULT.setLine(S1left); :}
			|
			(StatementBreak) BREAK SEMI_COLON {: RESULT=new StatementBreak(); :}
			|
			(StatementContinue) CONTINUE SEMI_COLON {: RESULT=new StatementContinue(); :}
			|
			(StatementReturnExpr) RETURN Expr:E1 SEMI_COLON {: RESULT=new StatementReturnExpr(E1); RESULT.setLine(E1left); :}
			|
			(StatementReturnVoid) RETURN SEMI_COLON {: RESULT=new StatementReturnVoid(); :}
			|
			(StatementRead) READ L_PAREN Designator:D1 R_PAREN SEMI_COLON {: RESULT=new StatementRead(D1); RESULT.setLine(D1left); :}
			|
			(StatementPrint) PRINT L_PAREN Expr:E1 PrintNumConstOptional:P2 R_PAREN SEMI_COLON {: RESULT=new StatementPrint(E1, P2); RESULT.setLine(E1left); :}
			|
			(StatementForeach) ForeachStatement:F1 SEMI_COLON {: RESULT=new StatementForeach(F1); RESULT.setLine(F1left); :}	// TODO
			|
			(StatementSection) L_BRACE StatementListE:S1 R_BRACE {: RESULT=new StatementSection(S1); RESULT.setLine(S1left); :}
			;
			
StatementWhileStart ::= (StatementWhileStart) WHILE {: RESULT=new StatementWhileStart(); :};
			
IfStatement ::= (IfStatement) IF L_PAREN ConditionInIf:C1 R_PAREN Statement:S2 {: RESULT=new IfStatement(C1, S2); RESULT.setLine(C1left); :};

ElseStatement ::= (ElseStatement) ELSE Statement:S1 {: RESULT=new ElseStatement(S1); RESULT.setLine(S1left); :};
								
ForeachStatement ::= (ForeachStatement) Designator:D1 DOT FOREACH L_PAREN IDENT:I2 ARROW Statement:S3 R_PAREN {: RESULT=new ForeachStatement(D1, I2, S3); RESULT.setLine(D1left); :};

PrintNumConstOptional ::= (PrintNumConstOptionalExists) COMMA NUM_CONST:N1 {: RESULT=new PrintNumConstOptionalExists(N1); RESULT.setLine(N1left); :}
						|
						(PrintNumConstOptionalEmpty) {: RESULT=new PrintNumConstOptionalEmpty(); :} /* e */
						;
						
DesignatorStatement ::= (DesignatorStatementAssign) DesignatorAssignopExpr:D1 {: RESULT=new DesignatorStatementAssign(D1); RESULT.setLine(D1left); :}
					|
					(DesignatorStatementAction) DesignatorAction:D1 {: RESULT=new DesignatorStatementAction(D1); RESULT.setLine(D1left); :} 
					|
					(DesignatorStatementAssignArray) L_SQUARE_BRACKET DesignatorListOptionalES:D1 R_SQUARE_BRACKET ASSIGN Designator:D2 {: RESULT=new DesignatorStatementAssignArray(D1, D2); RESULT.setLine(D1left); :} // TODO
					;
					
DesignatorListOptionalES ::= (DesignatorListOptionalESExist) DesignatorOptional:D1 {: RESULT=new DesignatorListOptionalESExist(D1); RESULT.setLine(D1left); :}
						|
						(DesignatorListOptionalESEmpty) DesignatorListOptionalES:D1 COMMA DesignatorOptional:D2 {: RESULT=new DesignatorListOptionalESEmpty(D1, D2); RESULT.setLine(D1left); :}
						;
										
DesignatorOptional ::= (DesignatorOptionalExist) Designator:D1 {: RESULT=new DesignatorOptionalExist(D1); RESULT.setLine(D1left); :}
					|
					(DesignatorOptionalEmpty) {: RESULT=new DesignatorOptionalEmpty(); :} /* e */
					;
					
DesignatorAction ::= (DesignatorActionMethodCall) Designator:designator L_PAREN ActParsOptional:A1 R_PAREN {: RESULT=new DesignatorActionMethodCall(designator, A1); RESULT.setLine(designatorleft); :}
					|
					(DesignatorActionInc) Designator:designator INC {: RESULT=new DesignatorActionInc(designator); RESULT.setLine(designatorleft); :}
					|
					(DesignatorActionDec) Designator:designator DEC {: RESULT=new DesignatorActionDec(designator); RESULT.setLine(designatorleft); :}
					;
					
DesignatorAssignopExpr ::= (DesignatorAssignopExpression) Designator:designator Assignop:A1 Expr:expr {: RESULT=new DesignatorAssignopExpression(designator, A1, expr); RESULT.setLine(designatorleft); :}
						|
						(DesignatorAssignopExprError) error:e {: parser.report_error("Assignment operation error at line: " + eleft, null); :} {: RESULT=new DesignatorAssignopExprError(); :}
						;
				
ActPars ::= (ActParsMultiple) ActPars:A1 COMMA Expr:expr {: RESULT=new ActParsMultiple(A1, expr); RESULT.setLine(A1left); :}
		|
		(ActParsSingle) Expr:expr {: RESULT=new ActParsSingle(expr); RESULT.setLine(exprleft); :}
		;
		
ActParsOptional ::= (ActParsOptionalExist) ActPars:A1 {: RESULT=new ActParsOptionalExist(A1); RESULT.setLine(A1left); :}
				|
				(ActParsOptionalEmpty) {: RESULT=new ActParsOptionalEmpty(); :} /* e */
				;

ConditionInIf ::= (ConditionInIfExists) Condition:C1 {: RESULT=new ConditionInIfExists(C1); RESULT.setLine(C1left); :}
				|
				(ConditionInIfError) error:e 
					{: 
						parser.syntax_error("Statement in If Condition error at line: " + eleft, null); 
						parser.log.info("Statement in If Condition error recovery successful."); 
					:} {: RESULT=new ConditionInIfError(); :}
				;

Condition ::= (ConditionMultiple) Condition:C1 OR CondTerm:C2 {: RESULT=new ConditionMultiple(C1, C2); RESULT.setLine(C1left); :}
			|
			(ConditionSingle) CondTerm:C1 {: RESULT=new ConditionSingle(C1); RESULT.setLine(C1left); :}
			;
			
CondTerm ::= (CondTermMultiple) CondTerm:C1 AND CondFact:C2 {: RESULT=new CondTermMultiple(C1, C2); RESULT.setLine(C1left); :}
			|
			(CondTermSingle) CondFact:C1 {: RESULT=new CondTermSingle(C1); RESULT.setLine(C1left); :}
			;

CondFact ::= (CondFact) Expr:E1 RelopExprOptional:R2 {: RESULT=new CondFact(E1, R2); RESULT.setLine(E1left); :};

RelopExprOptional ::= (RelopExprOptionalExist) Relop:R1 Expr:E2 {: RESULT=new RelopExprOptionalExist(R1, E2); RESULT.setLine(R1left); :}
					|
					(RelopExprOptionalEmpty) {: RESULT=new RelopExprOptionalEmpty(); :} /* e */
					;

Expr ::= (ExprSingleMinus) MINUS Term:term {: RESULT=new ExprSingleMinus(term); RESULT.setLine(termleft); :}
		|
		(ExprSingle) Term:term {: RESULT=new ExprSingle(term); RESULT.setLine(termleft); :}
		|
		(ExprMultiple) Expr:expr Addop:A1 Term:term {: RESULT=new ExprMultiple(expr, A1, term); RESULT.setLine(exprleft); :}
		;
				
Term ::= (TermMultiple) Term:term Mulop:M1 Factor:factor {: RESULT=new TermMultiple(term, M1, factor); RESULT.setLine(termleft); :}
		|
		(TermSingle) Factor:factor {: RESULT=new TermSingle(factor); RESULT.setLine(factorleft); :}
		;
			
Factor ::= (FactorDesignator) Designator:D1 {: RESULT=new FactorDesignator(D1); RESULT.setLine(D1left); :}
		|
		(FactorDesignatorMethodCall) Designator:designator L_PAREN ActParsOptional:A1 R_PAREN {: RESULT=new FactorDesignatorMethodCall(designator, A1); RESULT.setLine(designatorleft); :}
		| 
		(FactorNumConst) NUM_CONST:N1 {: RESULT=new FactorNumConst(N1); RESULT.setLine(N1left); :}
		| 
		(FactorCharConst) CHAR_CONST:C1 {: RESULT=new FactorCharConst(C1); RESULT.setLine(C1left); :}
		| 
		(FactorBoolConst) BOOL_CONST:B1 {: RESULT=new FactorBoolConst(B1); RESULT.setLine(B1left); :}
		|
		(FactorNewArray) NEW Type:type L_SQUARE_BRACKET Expr:expr R_SQUARE_BRACKET {: RESULT=new FactorNewArray(type, expr); RESULT.setLine(typeleft); :}
		|
		(FactorExpr) L_PAREN Expr:E1 R_PAREN {: RESULT=new FactorExpr(E1); RESULT.setLine(E1left); :}
		;

NewTypeSuffix ::= (NewTypeSuffixArray) L_SQUARE_BRACKET Expr:expr R_SQUARE_BRACKET {: RESULT=new NewTypeSuffixArray(expr); RESULT.setLine(exprleft); :}
				|
				(NewTypeSuffixClass) L_PAREN ActParsOptional:A1 R_PAREN {: RESULT=new NewTypeSuffixClass(A1); RESULT.setLine(A1left); :}
				;		
				
Designator ::= (DesignatorDot) Designator:designator DOT IDENT:field {: RESULT=new DesignatorDot(designator, field); RESULT.setLine(designatorleft); :}
			|
			(DesignatorSquareBrackets) Designator:designator L_SQUARE_BRACKET Expr:expr R_SQUARE_BRACKET {: RESULT=new DesignatorSquareBrackets(designator, expr); RESULT.setLine(designatorleft); :}
			|
			(DesignatorSingle) IDENT:designatorName {: RESULT=new DesignatorSingle(designatorName); RESULT.setLine(designatorNameleft); :}
			;
			
Label ::= (Label) IDENT:I1 {: RESULT=new Label(I1); RESULT.setLine(I1left); :};

Assignop ::= (Assignop) ASSIGN {: RESULT=new Assignop(); :};

Relop ::= (RelopEquals) EQUALS {: RESULT=new RelopEquals(); :}
		|
		(RelopNotEquals) NOT_EQUALS {: RESULT=new RelopNotEquals(); :}
		|
		(RelopGreater) GREATER {: RESULT=new RelopGreater(); :}
		|
		(RelopGreaterEquals) GREATER_EQUALS {: RESULT=new RelopGreaterEquals(); :}
		|
		(RelopLess) LESS {: RESULT=new RelopLess(); :}
		|
		(RelopLessEquals) LESS_EQUALS {: RESULT=new RelopLessEquals(); :}
		;
	
Addop ::= (AddopPlus) PLUS {: RESULT=new AddopPlus(); :}
		|
		(AddopMinus) MINUS {: RESULT=new AddopMinus(); :}
		;
		
Mulop ::= (AddopMul) MUL {: RESULT=new AddopMul(); :}
		|
		(AddopDiv) DIV {: RESULT=new AddopDiv(); :}
		|
		(AddopMod) MOD {: RESULT=new AddopMod(); :}
		;	
		
		
		